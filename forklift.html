<html lang="en">
<head>
  <title>Chain - Threejs + Ammo</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
  body {
    color: #61443e;
    font-family:Monospace;
    font-size:13px;
    text-align:center;

    background-color: #bfd1e5;
    margin: 0px;
    overflow: hidden;
  }

  #info {
    position: absolute;
    top: 0px; width: 100%;
    padding: 5px;
  }

  a {

    color: #a06851;
  }

  </style>
</head>
<body>
  <div id="info">Chain demo.</div>
  <div id="container"><br /><br /><br /><br /><br />Loading...</div>

  <script src="js/three.min.js"></script>
  <script src="js/libs/ammo.js"></script>
  <script src="js/controls/OrbitControls.js"></script>
  <script src="js/Detector.js"></script>
  <script src="js/libs/stats.min.js"></script>

  <script>

  // Detects webgl
  if ( ! Detector.webgl ) {
    Detector.addGetWebGLMessage();
    document.getElementById( 'container' ).innerHTML = "";
  }

  // - Global variables -

  // Graphics variables
  var container, stats;
  var camera, controls, scene, renderer;
  var textureLoader;
  var clock = new THREE.Clock();

  // Physics variables
  var gravityConstant = -9.8;
  var collisionConfiguration;
  var dispatcher;
  var broadphase;
  var solver;
  var softBodySolver;
  var physicsWorld;
  var rigidBodies = [];
  var margin = 0.05;
  var hinge;
  var rope;
  var transformAux1 = new Ammo.btTransform();

  var time = 0;
  var armMovement = 0;

  // - Main code -

  init();
  animate();


  // - Functions -

  function init() {

    initGraphics();

    initPhysics();

    createObjects();

    initInput();

  }

  function initGraphics() {

    container = document.getElementById( 'container' );

    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );

    scene = new THREE.Scene();

    camera.position.x = -7;
    camera.position.y = 4;
    camera.position.z =  -16;

    controls = new THREE.OrbitControls( camera );
    controls.target.copy(new THREE.Vector3(0, 4, -5));

    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor( 0xbfd1e5 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMap.enabled = true;

    textureLoader = new THREE.TextureLoader();

    var ambientLight = new THREE.AmbientLight( 0x404040 );
    scene.add( ambientLight );

    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set( -10, 10, 5 );
    light.castShadow = true;
    var d = 10;
    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

    light.shadow.camera.near = 2;
    light.shadow.camera.far = 50;

    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;

    scene.add( light );


    container.innerHTML = "";

    container.appendChild( renderer.domElement );

    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    container.appendChild( stats.domElement );

    //

    window.addEventListener( 'resize', onWindowResize, false );

  }

  function CarMesh(chassis, supp, chasisLocalPos, suppLocalPos) {
    let matrix;
    let merged = new THREE.Geometry();
    let chassisMesh = new THREE.BoxGeometry(...chassis);
    let suppShapeMesh = new THREE.BoxGeometry(...supp);

    matrix = new THREE.Matrix4();
    matrix.makeTranslation(...chasisLocalPos);
    chassisMesh.applyMatrix(matrix);

    matrix = new THREE.Matrix4();
    matrix.makeTranslation(...suppLocalPos);
    suppShapeMesh.applyMatrix(matrix);

    merged.merge(chassisMesh);
    merged.merge(suppShapeMesh);

    matrix = new THREE.Matrix4();
    matrix.makeScale(2, 2, 2);
    merged.applyMatrix(matrix);

    return merged;
  }

  function createCar() {
    let chassis = [1, .5, 2];
    let chasisLocalPos = [0,1,0];
    let supp = [.5, .1, .5];
    let suppLocalPos = [0, 1, 1.25];
    let carMaterial = new THREE.MeshPhongMaterial( {
      color: 0xff01c6
    } );

    let chassisShape = new Ammo.btBoxShape(new Ammo.btVector3(...chassis));
    let compound = new Ammo.btCompoundShape();

    let localTransform = new Ammo.btTransform;
    localTransform.setIdentity();
    localTransform.setOrigin(new Ammo.btVector3(...chasisLocalPos));

    compound.addChildShape(localTransform, chassisShape);
    let suppShape = new Ammo.btBoxShape(new Ammo.btVector3(...supp));

    let suppLocalTrans = new Ammo.btTransform();
		suppLocalTrans.setIdentity();
    localTransform.setOrigin(new Ammo.btVector3( ...suppLocalPos ));

		compound.addChildShape(suppLocalTrans, suppShape);

    let carMesh = new THREE.Mesh(
      CarMesh(chassis, supp, chasisLocalPos, suppLocalPos),
      carMaterial
    );

    let carRigidBody = createRigidBody(
      carMesh,
      compound,
      800, // Mass
      new THREE.Vector3(0, 0, 0), // Position
      new THREE.Quaternion() // Rotation
    );
    //
    // let suppShape = new Ammo.btBoxShape(new Ammo.btVector3(0.5,0.1,0.5));
    // let suppLocalTrans = new Ammo.btTransform();
    // suppLocalTrans.setIdentity();
    // //localTrans effectively shifts the center of mass with respect to the chassis
    // suppLocalTrans.setOrigin(new Ammo.btVector3(0,1.0,2.5));
    // compound.addChildShape(suppLocalTrans, suppShape);
    // let liftShape = new Ammo.btBoxShape(.5, 2, .05);
    // let liftMesh = new THREE.Mesh( new THREE.BoxBufferGeometry(1, .025, .25), carMaterial );
    // liftMesh.castShadow = true;
    // liftMesh.receiveShadow = true;
    // let liftQuaternion = new THREE.Quaternion();
    // // liftQuaternion.set(0,0,0,1);
    // let liftBody = createRigidBody(
    //   liftMesh, liftShape,
    //   10.0, // Mass
    //   new THREE.Vector3(0, 2.5, 3.05), // Position
    //   liftQuaternion // Rotation
    // );
  }

  function createCargo(){
    let cargoSide = [.1, 1, 1];
    let cargoCenter = [2, .5, .5];

    let cargoMaterial = new THREE.MeshPhongMaterial( {
      color: 0xff01c6
    } );
    let cargoMesh = new THREE.Mesh(
      new CargoMesh(cargoSide, cargoCenter), cargoMaterial
    );
    cargoMesh.castShadow = true;
    cargoMesh.receiveShadow = true;

    let loadCompound = new Ammo.btCompoundShape();
		let loadShapeA = new Ammo.btBoxShape(new Ammo.btVector3(...cargoCenter));
		let loadTrans = new Ammo.btTransform();
		loadTrans.setIdentity();
		loadCompound.addChildShape(loadTrans, loadShapeA);
		let loadShapeB = new Ammo.btBoxShape(new Ammo.btVector3(...cargoSide));
		loadTrans.setIdentity();
		loadTrans.setOrigin(new Ammo.btVector3(2.1, 0.0, 0.0));
		loadCompound.addChildShape(loadTrans, loadShapeB);
		let loadShapeC = new Ammo.btBoxShape(new Ammo.btVector3(...cargoSide));
		loadTrans.setIdentity();
		loadTrans.setOrigin(new Ammo.btVector3(-2.1, 0.0, 0.0));
		loadCompound.addChildShape(loadTrans, loadShapeC);
		let loadBody  = createRigidBody(
      cargoMesh, loadCompound,
      350, //mass
      new THREE.Vector3(0.0, 3.5, 7.0), // position
      new THREE.Quaternion()// rotation
    );
  }

  function CargoMesh(cargoSide, cargoCenter){
    let merged = new THREE.Geometry();
    let left = new THREE.BoxGeometry(...cargoSide);
    let right = new THREE.BoxGeometry(...cargoSide);
    let center = new THREE.BoxGeometry(...cargoCenter);
    let matrix = new THREE.Matrix4();

    matrix.makeTranslation(1.05, 0, 0);
    left.applyMatrix(matrix);

    matrix = new THREE.Matrix4();
    matrix.makeTranslation(-1.05, 0, 0);
    right.applyMatrix(matrix);

    merged.merge(left);
    merged.merge(right);
    merged.merge(center);

    matrix = new THREE.Matrix4();
    matrix.makeScale(2, 2, 2);
    merged.applyMatrix(matrix);

    return merged;

  }

  function CapsuleMesh(radius, height) {
    var merged = new THREE.Geometry();
    var cyl = new THREE.CylinderGeometry(radius, radius, height);
    var top = new THREE.SphereGeometry(radius);
    var bot = new THREE.SphereGeometry(radius);

    var matrix = new THREE.Matrix4();
    matrix.makeTranslation(0, height*0.5, 0);
    top.applyMatrix(matrix);
    var matrix = new THREE.Matrix4();
    matrix.makeTranslation(0, -height*0.5, 0);
    bot.applyMatrix(matrix);
    // merge to create a capsule
    merged.merge(top);
    merged.merge(bot);
    merged.merge(cyl);
    merged.rotateZ(90*(Math.PI/180));
    return merged;
  }

  function initPhysics() {

    // Physics configuration

    collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    softBodySolver = new Ammo.btDefaultSoftBodySolver();
    physicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
    physicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );
    physicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );

  }

  function createObjects() {

    var pos = new THREE.Vector3();
    var quat = new THREE.Quaternion();

    // Ground
    pos.set( 0, - 0.5, 0 );
    quat.set( 0, 0, 0, 1 );
    var ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
    ground.castShadow = true;
    ground.receiveShadow = true;
    textureLoader.load( "textures/grid.png", function( texture ) {
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set( 40, 40 );
      ground.material.map = texture;
      ground.material.needsUpdate = true;
    } );

    // Lift Object
    createCargo();
    createCar();


    // Chain
    var chainMass = 1.;
    var chainPos = new THREE.Vector3(0,5,0);
    var chainQuat = new THREE.Quaternion();
    // chainQuat.set( 0, 0, 0, 1 );

		var chainShape = new Ammo.btCapsuleShapeX(0.2, 0.6);
    var anchor = new THREE.Vector3(1,0,0);
		var anchor = new THREE.Vector3(0, 10, -5);
		const numLinks = 8;
		var link = [];

    var chainMaterial = new THREE.MeshPhongMaterial( {
      color: 0xff01c6 ,
      shininess: 120
    } );

		for (var i = 0; i < numLinks; i++) {
      let nodeMesh = new THREE.Mesh( new CapsuleMesh( 0.2, 0.6 ), chainMaterial );
      nodeMesh.castShadow = true;
      nodeMesh.receiveShadow = true;
      var chainOrigin = new THREE.Vector3(1*(i+0.5), 10, -5);
      link.push(
        createRigidBody(nodeMesh, chainShape, chainMass, chainOrigin, chainQuat)
      );
		}
    var linkEnd = new Ammo.btVector3(1,0,0);
    var leftEnd = new Ammo.btVector3(0.5, 0, 0);
    var rightEnd = new Ammo.btVector3(-0.5, 0, 0);

    physicsWorld.addConstraint(
			new Ammo.btPoint2PointConstraint(link[0], rightEnd), true
    );
		for (var i = 1; i < numLinks; i++){
			physicsWorld.addConstraint(
				new Ammo.btPoint2PointConstraint(link[i-1], link[i], leftEnd, rightEnd),	true
      );
    }
  }

  function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

    var threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );
    var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
    shape.setMargin( margin );

    createRigidBody( threeObject, shape, mass, pos, quat );

    return threeObject;

  }

  function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

    threeObject.position.copy( pos );
    threeObject.quaternion.copy( quat );

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
    transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
    var motionState = new Ammo.btDefaultMotionState( transform );

    var localInertia = new Ammo.btVector3( 0, 0, 0 );
    physicsShape.calculateLocalInertia( mass, localInertia );

    var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
    var body = new Ammo.btRigidBody( rbInfo );

    threeObject.userData.physicsBody = body;

    scene.add( threeObject );

    if ( mass > 0 ) {
      rigidBodies.push( threeObject );

      // Disable deactivation
      body.setActivationState( 4 );
    }

    physicsWorld.addRigidBody( body );
    return body;

  }

  function createRandomColor() {
    return Math.floor( Math.random() * ( 1 << 24 ) );
  }

  function createMaterial() {
    return new THREE.MeshPhongMaterial( { color: createRandomColor() } );
  }

  function initInput() {

    window.addEventListener( 'keydown', function( event ) {

      switch ( event.keyCode ) {
        // Q
        case 81:
        armMovement = 1;
        break;

        // A
        case 65:
        armMovement = - 1;
        break;
      }

    }, false );

    window.addEventListener( 'keyup', function( event ) {

      armMovement = 0;

    }, false );

  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function animate() {

    requestAnimationFrame( animate );

    render();
    stats.update();

  }

  function render() {

    var deltaTime = clock.getDelta();

    updatePhysics( deltaTime );

    controls.update( deltaTime );

    renderer.render( scene, camera );

    time += deltaTime;

  }

  function updatePhysics( deltaTime ) {
    physicsWorld.stepSimulation( deltaTime, 10 );
    // Update rigid bodies
    for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
      var objThree = rigidBodies[ i ];
      var objPhys = objThree.userData.physicsBody;
      var ms = objPhys.getMotionState();
      if ( ms ) {
        ms.getWorldTransform( transformAux1 );
        var p = transformAux1.getOrigin();
        var q = transformAux1.getRotation();
        objThree.position.set( p.x(), p.y(), p.z() );
        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
      }
    }
  }

  </script>

</body>
</html>
