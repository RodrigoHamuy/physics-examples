<html lang="en">
<head>
  <title>Chain - Threejs + Ammo</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
  body {
    color: #61443e;
    font-family:Monospace;
    font-size:13px;
    text-align:center;

    background-color: #bfd1e5;
    margin: 0px;
    overflow: hidden;
  }

  #info {
    position: absolute;
    top: 0px; width: 100%;
    padding: 5px;
  }

  a {

    color: #a06851;
  }

  </style>
</head>
<body>
  <div id="info">Chain demo.</div>
  <div id="container"><br /><br /><br /><br /><br />Loading...</div>

  <script src="js/three.min.js"></script>
  <script src="js/libs/ammo.js"></script>
  <script src="js/controls/OrbitControls.js"></script>
  <script src="js/Detector.js"></script>
  <script src="js/libs/stats.min.js"></script>

  <script>

  // Detects webgl
  if ( ! Detector.webgl ) {
    Detector.addGetWebGLMessage();
    document.getElementById( 'container' ).innerHTML = "";
  }

  // - Global variables -

  // Graphics variables
  var container, stats;
  var camera, controls, scene, renderer;
  var textureLoader;
  var clock = new THREE.Clock();

  // Physics variables
  var gravityConstant = -9.8;
  var collisionConfiguration;
  var dispatcher;
  var broadphase;
  var solver;
  var softBodySolver;
  var physicsWorld;
  var rigidBodies = [];
  var margin = 0.05;
  var hinge;
  var rope;
  var transformAux1 = new Ammo.btTransform();

  var time = 0;
  var armMovement = 0;

	var clickRequest = false;
	var mouseCoords = new THREE.Vector2();
	var raycaster = new THREE.Raycaster();
	var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
	var pos = new THREE.Vector3();
	var quat = new THREE.Quaternion();


  // - Main code -

  init();
  animate();


  // - Functions -

  function init() {

    initGraphics();

    initPhysics();

    createObjects();

    initInput();

  }

  function initGraphics() {

    container = document.getElementById( 'container' );

    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );

    scene = new THREE.Scene();

    camera.position.x = -7;
    camera.position.y = 4;
    camera.position.z =  -16;

    controls = new THREE.OrbitControls( camera );
    controls.target.copy(new THREE.Vector3(0, 4, -5));

    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor( 0xbfd1e5 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMap.enabled = true;

    textureLoader = new THREE.TextureLoader();

    var ambientLight = new THREE.AmbientLight( 0x404040 );
    scene.add( ambientLight );

    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set( -10, 10, 5 );
    light.castShadow = true;
    var d = 10;
    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

    light.shadow.camera.near = 2;
    light.shadow.camera.far = 50;

    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;

    scene.add( light );


    container.innerHTML = "";

    container.appendChild( renderer.domElement );

    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    container.appendChild( stats.domElement );

    //

    window.addEventListener( 'resize', onWindowResize, false );

  }

  function CarMesh(chassis, supp, chasisLocalPos, suppLocalPos) {
    let matrix;
    let merged = new THREE.Geometry();
    let chassisMesh = new THREE.BoxGeometry(...chassis);
    let suppShapeMesh = new THREE.BoxGeometry(...supp);

    matrix = new THREE.Matrix4();
    matrix.makeScale(2, 2, 2);
    chassisMesh.applyMatrix(matrix);
    matrix = new THREE.Matrix4();
    matrix.makeTranslation(...chasisLocalPos);
    chassisMesh.applyMatrix(matrix);
    merged.merge(chassisMesh);

    matrix = new THREE.Matrix4();
    matrix.makeScale(2, 2, 2);
    suppShapeMesh.applyMatrix(matrix);
    matrix = new THREE.Matrix4();
    matrix.makeTranslation(...suppLocalPos);
    suppShapeMesh.applyMatrix(matrix);
    merged.merge(suppShapeMesh);


    return merged;
  }

  function createCar() {
    let chassis = [1, .5, 2];
    let chasisLocalPos = [0,1,0];
    let supp = [.5, .1, .5];
    let suppLocalPos = [0, 1, 1.25];
    let carMaterial = new THREE.MeshPhongMaterial( {
      color: 0xff01c6
    } );

    let chassisShape = new Ammo.btBoxShape(new Ammo.btVector3(...chassis));
    let compound = new Ammo.btCompoundShape();

    let localTransform = new Ammo.btTransform;
    localTransform.setIdentity();
    localTransform.setOrigin(new Ammo.btVector3(...chasisLocalPos));
    compound.addChildShape(localTransform, chassisShape);

    let suppShape = new Ammo.btBoxShape(new Ammo.btVector3(...supp));

    let suppLocalTrans = new Ammo.btTransform();
		suppLocalTrans.setIdentity();
    suppLocalTrans.setOrigin(new Ammo.btVector3( ...suppLocalPos ));

		compound.addChildShape(suppLocalTrans, suppShape);

    let carMesh = new THREE.Mesh(
      CarMesh(chassis, supp, chasisLocalPos, suppLocalPos),
      carMaterial
    );
    carMesh.castShadow = true;
    carMesh.receiveShadow = true;

    let carRigidBody = createRigidBody(
      carMesh,
      compound,
      800, // Mass
      new THREE.Vector3(0, 0, 0), // Position
      new THREE.Quaternion() // Rotation
    );

    // WHEELS
    /*
    let	wheelRadius = .5;
    let	wheelWidth = .4;
    let	wheelFriction = 1000;

    let wheelShape = new Ammo.btCylinderShapeX(new Ammo.btVector3(wheelWidth,wheelRadius,wheelRadius));
    // let wheelShape = new Ammo.btBoxShape(new Ammo.btVector3(.5, 2, .05) );
    let wheelMesh = new THREE.Mesh(
      new THREE.CylinderGeometry( wheelRadius, wheelRadius, wheelWidth )
    );
    wheelMesh.castShadow = true;
    wheelMesh.receiveShadow = true;

    let wheelPos = new THREE.Vector3(0, 2.5, 3.05);
		wheelBody = createRigidBody(
      wheelMesh, wheelShape,
      10, wheelPos, new THREE.Quaternion()
    );
    */

    let liftDimensions = [.5, 2, .05];
    let liftGeometry = new THREE.BoxGeometry(...liftDimensions);
    let liftPos = [0, 2.5, 3.05];
    let matrix = new THREE.Matrix4();
    matrix.makeTranslation( 2, 2, 2 );
    liftGeometry.applyMatrix(matrix);

    let liftMesh = new THREE.Mesh(
      liftGeometry,
      carMaterial
    );


    let liftShape = new Ammo.btBoxShape(new Ammo.btVector3( ...liftDimensions ));
		let liftTrans = new Ammo.btTransform();
		let liftStartPos = new Ammo.btVector3( 0, 2.5, 3.05 );
		liftTrans.setIdentity();
		liftTrans.setOrigin(liftStartPos);
		let liftBody = createRigidBody(
      liftMesh, liftShape,
      10,
      new THREE.Vector3(...liftPos),
      new THREE.Quaternion()
    );
  }

  function LiftMesh() {

  }

  function createCargo(){
    let cargoSide = [.1, 1, 1];
    let cargoCenter = [2, .5, .5];

    let cargoMaterial = new THREE.MeshPhongMaterial( {
      color: 0xff01c6
    } );
    let cargoMesh = new THREE.Mesh(
      new CargoMesh(cargoSide, cargoCenter), cargoMaterial
    );
    cargoMesh.castShadow = true;
    cargoMesh.receiveShadow = true;

    let loadCompound = new Ammo.btCompoundShape();
		let loadShapeA = new Ammo.btBoxShape(new Ammo.btVector3(...cargoCenter));
		let loadTrans = new Ammo.btTransform();
		loadTrans.setIdentity();
		loadCompound.addChildShape(loadTrans, loadShapeA);
		let loadShapeB = new Ammo.btBoxShape(new Ammo.btVector3(...cargoSide));
		loadTrans.setIdentity();
		loadTrans.setOrigin(new Ammo.btVector3(2.1, 0.0, 0.0));
		loadCompound.addChildShape(loadTrans, loadShapeB);
		let loadShapeC = new Ammo.btBoxShape(new Ammo.btVector3(...cargoSide));
		loadTrans.setIdentity();
		loadTrans.setOrigin(new Ammo.btVector3(-2.1, 0.0, 0.0));
		loadCompound.addChildShape(loadTrans, loadShapeC);
		let loadBody  = createRigidBody(
      cargoMesh, loadCompound,
      350, //mass
      new THREE.Vector3(0.0, 3.5, 7.0), // position
      new THREE.Quaternion()// rotation
    );
  }

  function CargoMesh(cargoSide, cargoCenter){
    let merged = new THREE.Geometry();
    let left = new THREE.BoxGeometry(...cargoSide);
    let right = new THREE.BoxGeometry(...cargoSide);
    let center = new THREE.BoxGeometry(...cargoCenter);
    let matrix = new THREE.Matrix4();

    matrix.makeTranslation(1.05, 0, 0);
    left.applyMatrix(matrix);

    matrix = new THREE.Matrix4();
    matrix.makeTranslation(-1.05, 0, 0);
    right.applyMatrix(matrix);

    merged.merge(left);
    merged.merge(right);
    merged.merge(center);

    matrix = new THREE.Matrix4();
    matrix.makeScale(2, 2, 2);
    merged.applyMatrix(matrix);

    return merged;

  }

  function CapsuleMesh(radius, height) {
    var merged = new THREE.Geometry();
    var cyl = new THREE.CylinderGeometry(radius, radius, height);
    var top = new THREE.SphereGeometry(radius);
    var bot = new THREE.SphereGeometry(radius);

    var matrix = new THREE.Matrix4();
    matrix.makeTranslation(0, height*0.5, 0);
    top.applyMatrix(matrix);
    var matrix = new THREE.Matrix4();
    matrix.makeTranslation(0, -height*0.5, 0);
    bot.applyMatrix(matrix);
    // merge to create a capsule
    merged.merge(top);
    merged.merge(bot);
    merged.merge(cyl);
    merged.rotateZ(90*(Math.PI/180));
    return merged;
  }

  function initPhysics() {

    // Physics configuration

    collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    softBodySolver = new Ammo.btDefaultSoftBodySolver();
    physicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
    physicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );
    physicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );

  }

  function createObjects() {

    var pos = new THREE.Vector3();
    var quat = new THREE.Quaternion();

    // Ground
    pos.set( 0, - 0.5, 0 );
    quat.set( 0, 0, 0, 1 );
    var ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
    ground.castShadow = true;
    ground.receiveShadow = true;
    textureLoader.load( "textures/grid.png", function( texture ) {
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set( 40, 40 );
      ground.material.map = texture;
      ground.material.needsUpdate = true;
    } );

    createCar();
  }

  function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

    var threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );
    var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
    shape.setMargin( margin );

    createRigidBody( threeObject, shape, mass, pos, quat );

    return threeObject;

  }

  function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

    threeObject.position.copy( pos );
    threeObject.quaternion.copy( quat );

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
    transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
    var motionState = new Ammo.btDefaultMotionState( transform );

    var localInertia = new Ammo.btVector3( 0, 0, 0 );
    physicsShape.calculateLocalInertia( mass, localInertia );

    var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
    var body = new Ammo.btRigidBody( rbInfo );

    threeObject.userData.physicsBody = body;

    scene.add( threeObject );

    if ( mass > 0 ) {
      rigidBodies.push( threeObject );

      // Disable deactivation
      body.setActivationState( 4 );
    }

    physicsWorld.addRigidBody( body );
    return body;

  }

  function createRandomColor() {
    return Math.floor( Math.random() * ( 1 << 24 ) );
  }

  function createMaterial() {
    return new THREE.MeshPhongMaterial( { color: createRandomColor() } );
  }

  function initInput() {
    window.addEventListener( 'mousedown', function( event ) {
      if ( ! clickRequest ) {
        mouseCoords.set(
          ( event.clientX / window.innerWidth ) * 2 - 1,
          - ( event.clientY / window.innerHeight ) * 2 + 1
        );
        clickRequest = true;
      }
    }, false );
  }

  function processClick() {
    if ( clickRequest ) {
      raycaster.setFromCamera( mouseCoords, camera );
      // Creates a ball
      var ballMass = 3;
      var ballRadius = 0.4;
      var ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 18, 16 ), ballMaterial );
      ball.castShadow = true;
      ball.receiveShadow = true;
      var ballShape = new Ammo.btSphereShape( ballRadius );
      ballShape.setMargin( margin );
      pos.copy( raycaster.ray.direction );
      pos.add( raycaster.ray.origin );
      quat.set( 0, 0, 0, 1 );
      var ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );
      ballBody.setFriction( 0.5 );
      pos.copy( raycaster.ray.direction );
      pos.multiplyScalar( 14 );
      ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
      clickRequest = false;
    }
  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function animate() {

    requestAnimationFrame( animate );

    render();
    stats.update();

  }

  function render() {

    var deltaTime = clock.getDelta();

    updatePhysics( deltaTime );

		processClick();

    controls.update( deltaTime );

    renderer.render( scene, camera );

    time += deltaTime;

  }

  function updatePhysics( deltaTime ) {
    physicsWorld.stepSimulation( deltaTime, 10 );
    // Update rigid bodies
    for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
      var objThree = rigidBodies[ i ];
      var objPhys = objThree.userData.physicsBody;
      var ms = objPhys.getMotionState();
      if ( ms ) {
        ms.getWorldTransform( transformAux1 );
        var p = transformAux1.getOrigin();
        var q = transformAux1.getRotation();
        objThree.position.set( p.x(), p.y(), p.z() );
        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
      }
    }
  }

  </script>

</body>
</html>
