<html lang="en">
<head>
  <title>Chain - Threejs + Ammo</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
  body {
    color: #61443e;
    font-family:Monospace;
    font-size:13px;
    text-align:center;

    background-color: #bfd1e5;
    margin: 0px;
    overflow: hidden;
  }

  #info {
    position: absolute;
    top: 0px; width: 100%;
    padding: 5px;
  }

  a {

    color: #a06851;
  }

  </style>
</head>
<body>
  <div id="info">Chain demo.</div>
  <div id="container"><br /><br /><br /><br /><br />Loading...</div>

  <script src="js/three.min.js"></script>
  <script src="js/libs/ammo.js"></script>
  <script src="js/controls/OrbitControls.js"></script>
  <script src="js/Detector.js"></script>
  <script src="js/libs/stats.min.js"></script>

  <script>

  // Detects webgl
  if ( ! Detector.webgl ) {
    Detector.addGetWebGLMessage();
    document.getElementById( 'container' ).innerHTML = "";
  }

  // - Global variables -

  // Graphics variables
  var container, stats;
  var camera, controls, scene, renderer;
  var textureLoader;
  var clock = new THREE.Clock();

  // Physics variables
  var gravityConstant = -9.8;
  var collisionConfiguration;
  var dispatcher;
  var broadphase;
  var solver;
  var softBodySolver;
  var physicsWorld;
  var rigidBodies = [];
  var margin = 0.05;
  var hinge;
  var rope;
  var transformAux1 = new Ammo.btTransform();

  var time = 0;
  var armMovement = 0;

	var clickRequest = false;
	var mouseCoords = new THREE.Vector2();
	var raycaster = new THREE.Raycaster();
	var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
	var pos = new THREE.Vector3();
	var quat = new THREE.Quaternion();

  // Car variables
  var carChassis, liftBody, vehicleRayCaster, vehicle, m_tuning;
  var	gEngineForce = 0;
  var gBreakingForce = 0;
  var gVehicleSteering = 0;
  var	maxEngineForce = 1000;
  var maxBreakingForce = 100;
  var steeringIncrement = 0.04;
  var steeringClamp = 0.3;
  var wheelsThreeObjs = [];

  // - Main code -

  init();
  animate();


  // - Functions -

  function init() {

    initGraphics();

    initPhysics();

    createObjects();

    initInput();

  }

  function initGraphics() {

    container = document.getElementById( 'container' );

    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );

    scene = new THREE.Scene();

    camera.position.x = -7;
    camera.position.y = 4;
    camera.position.z =  -16;

    controls = new THREE.OrbitControls( camera );
    controls.target.copy(new THREE.Vector3(0, 4, -5));

    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor( 0xbfd1e5 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMap.enabled = true;

    textureLoader = new THREE.TextureLoader();

    var ambientLight = new THREE.AmbientLight( 0x404040 );
    scene.add( ambientLight );

    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set( -10, 10, 5 );
    light.castShadow = true;
    var d = 10;
    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

    light.shadow.camera.near = 2;
    light.shadow.camera.far = 50;

    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;

    scene.add( light );


    container.innerHTML = "";

    container.appendChild( renderer.domElement );

    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    container.appendChild( stats.domElement );

    //

    window.addEventListener( 'resize', onWindowResize, false );

  }

  function CarMesh(chassis, supp, chasisLocalPos, suppLocalPos) {
    let matrix;
    let merged = new THREE.Geometry();
    let chassisMesh = new THREE.BoxGeometry(...chassis);
    let suppShapeMesh = new THREE.BoxGeometry(...supp);

    matrix = new THREE.Matrix4();
    matrix.makeScale(2, 2, 2);
    chassisMesh.applyMatrix(matrix);
    matrix = new THREE.Matrix4();
    matrix.makeTranslation(...chasisLocalPos);
    chassisMesh.applyMatrix(matrix);
    merged.merge(chassisMesh);

    matrix = new THREE.Matrix4();
    matrix.makeScale(2, 2, 2);
    suppShapeMesh.applyMatrix(matrix);
    matrix = new THREE.Matrix4();
    matrix.makeTranslation(...suppLocalPos);
    suppShapeMesh.applyMatrix(matrix);
    merged.merge(suppShapeMesh);


    return merged;
  }


  function clientResetScene()
  {
  	gVehicleSteering = 0;
  	carChassis.setCenterOfMassTransform( new Ammo.btTransform() );
  	carChassis.setLinearVelocity(new Ammo.btVector3(0,0,0));
  	carChassis.setAngularVelocity(new Ammo.btVector3(0,0,0));
  	// physicsWorld.getBroadphase().getOverlappingPairCache().cleanProxyFromPairs(
    //   carChassis.getBroadphaseHandle(),
    //   physicsWorld.getDispatcher()
    // );
  	// if (m_vehicle)
  	// {
  	// 	m_vehicle->resetSuspension();
  	// 	for (int i=0;i<m_vehicle->getNumWheels();i++)
  	// 	{
  	// 		//synchronize the wheels with the (interpolated) chassis worldtransform
  	// 		m_vehicle->updateWheelTransform(i,true);
  	// 	}
  	// }
  }

  function createCar() {
    let chassis = [1, .5, 2];
    let chasisLocalPos = [0,1,0];
    let supp = [.5, .1, .5];
    let suppLocalPos = [0, 1, 1.25];
    let carMaterial = new THREE.MeshPhongMaterial( {
      color: 0xff01c6
    } );

    let chassisShape = new Ammo.btBoxShape(new Ammo.btVector3(...chassis));
    let compound = new Ammo.btCompoundShape();

    let localTransform = new Ammo.btTransform;
    localTransform.setIdentity();
    localTransform.setOrigin(new Ammo.btVector3(...chasisLocalPos));
    compound.addChildShape(localTransform, chassisShape);

    let suppShape = new Ammo.btBoxShape(new Ammo.btVector3(...supp));

    let suppLocalTrans = new Ammo.btTransform();
		suppLocalTrans.setIdentity();
    suppLocalTrans.setOrigin(new Ammo.btVector3( ...suppLocalPos ));

		compound.addChildShape(suppLocalTrans, suppShape);

    let carMesh = new THREE.Mesh(
      CarMesh(chassis, supp, chasisLocalPos, suppLocalPos),
      carMaterial
    );
    carMesh.castShadow = true;
    carMesh.receiveShadow = true;

    carChassis = createRigidBody(
      carMesh,
      compound,
      800, // Mass
      new THREE.Vector3(0, 0, 0), // Position
      new THREE.Quaternion() // Rotation
    );

    clientResetScene();

    // WHEELS
    let	wheelRadius = .5;
    let	wheelWidth = .4;
    let	wheelFriction = 1000;

    // let wheelShape = new Ammo.btCylinderShapeX(new Ammo.btVector3(wheelWidth,wheelRadius,wheelRadius));
    // let wheelShape = new Ammo.btBoxShape(new Ammo.btVector3(.5, 2, .05) );

    let wheelMaterial = new THREE.MeshPhongMaterial( {
      color: 0x36c1e2
    } );
    let wheelGeometry = new THREE.CylinderGeometry( wheelRadius, wheelRadius, wheelWidth );

    let matrix1 = new THREE.Matrix4();
    matrix1.makeRotationZ( 90*(Math.PI/180) );
    wheelGeometry.applyMatrix(matrix1);

    for (let i = 0; i < 4; i++) {
      let wheelMesh = new THREE.Mesh(
        wheelGeometry,
        wheelMaterial
      );
      wheelMesh.castShadow = true;
      wheelMesh.receiveShadow = true;
      scene.add(wheelMesh);

      wheelsThreeObjs.push(wheelMesh)
    }



    // let wheelPos = new THREE.Vector3(0, 2.5, 3.05);
    // wheelBody = createRigidBody(
    //   wheelMesh, wheelShape,
    //   10, wheelPos, new THREE.Quaternion()
    // );


    // Create vehicle
    (function () {
      tuning = new Ammo.btVehicleTuning();
      vehicleRayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
      vehicle = new Ammo.btRaycastVehicle(tuning,carChassis,vehicleRayCaster);

      ///never deactivate the vehicle
      carChassis.setActivationState(4);

      physicsWorld.addAction(vehicle);

      var connectionHeight = 1.2;
      var isFrontWheel=true;

      //choose coordinate system
      vehicle.setCoordinateSystem(0,1,2);

      var connectionPointCS0 = new Ammo.btVector3(1-(0.3*wheelWidth),connectionHeight,2*1-wheelRadius);
      let wheelDirectionCS0 = new Ammo.btVector3(0,-1,0);
      let wheelAxleCS = new Ammo.btVector3(-1,0,0);
      let suspensionRestLength = .6;
      vehicle.addWheel(
        connectionPointCS0,wheelDirectionCS0,wheelAxleCS,suspensionRestLength,wheelRadius,tuning,isFrontWheel
      );
      connectionPointCS0 = new Ammo.btVector3(-1+(0.3*wheelWidth),connectionHeight,2*1-wheelRadius);
      vehicle.addWheel(
        connectionPointCS0,wheelDirectionCS0,wheelAxleCS,suspensionRestLength,wheelRadius,tuning,isFrontWheel
      );
      connectionPointCS0 = new Ammo.btVector3(-1+(0.3*wheelWidth),connectionHeight,-2*1+wheelRadius);
      isFrontWheel = false;
      vehicle.addWheel(connectionPointCS0,wheelDirectionCS0,wheelAxleCS,suspensionRestLength,wheelRadius,tuning,isFrontWheel);
      connectionPointCS0 = new Ammo.btVector3(1-(0.3*wheelWidth),connectionHeight,-2*1+wheelRadius);
      vehicle.addWheel(connectionPointCS0,wheelDirectionCS0,wheelAxleCS,suspensionRestLength,wheelRadius,tuning,isFrontWheel);


      let	suspensionStiffness = 20;
      let	suspensionDamping = 2.3;
      let	suspensionCompression = 4.4;
      let wheelFriction = 1000;
      let	rollInfluence = 0.1;

      for (let i=0;i<vehicle.getNumWheels();i++){
        let wheel = vehicle.getWheelInfo(i);
        wheel.m_suspensionStiffness = suspensionStiffness;
        wheel.m_wheelsDampingRelaxation = suspensionDamping;
        wheel.m_wheelsDampingCompression = suspensionCompression;
        wheel.m_frictionSlip = wheelFriction;
        wheel.m_rollInfluence = rollInfluence;
      }

    })();

  }

  function updateCar() {
    let wheelIndex = 2;
		vehicle.applyEngineForce(gEngineForce,wheelIndex);
		vehicle.setBrake(gBreakingForce,wheelIndex);
		wheelIndex = 3;
		vehicle.applyEngineForce(gEngineForce,wheelIndex);
		vehicle.setBrake(gBreakingForce,wheelIndex);


		wheelIndex = 0;
		vehicle.setSteeringValue(gVehicleSteering,wheelIndex);
		wheelIndex = 1;
		vehicle.setSteeringValue(gVehicleSteering,wheelIndex);

    for (let i=0; i<vehicle.getNumWheels();i++)	{
      //synchronize the wheels with the (interpolated) chassis worldtransform
      vehicle.updateWheelTransform(i,true);
      //draw wheels (cylinders)
      let transformAux1 = vehicle.getWheelTransformWS(i);
      let objThree = wheelsThreeObjs[i];
      let p = transformAux1.getOrigin();
      let q = transformAux1.getRotation();
      objThree.position.set( p.x(), p.y(), p.z() );
      objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
    }
  }

  function initPhysics() {

    // Physics configuration

    collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    softBodySolver = new Ammo.btDefaultSoftBodySolver();
    physicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
    physicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );
    physicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );

  }

  function createObjects() {

    var pos = new THREE.Vector3();
    var quat = new THREE.Quaternion();

    // Ground
    pos.set( 0, - 0.5, 0 );
    quat.set( 0, 0, 0, 1 );
    var ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
    ground.castShadow = true;
    ground.receiveShadow = true;
    textureLoader.load( "textures/grid.png", function( texture ) {
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set( 40, 40 );
      ground.material.map = texture;
      ground.material.needsUpdate = true;
    } );

    createCar();
  }

  function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

    var threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );
    var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
    shape.setMargin( margin );

    createRigidBody( threeObject, shape, mass, pos, quat );

    return threeObject;

  }

  function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

    threeObject.position.copy( pos );
    threeObject.quaternion.copy( quat );

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
    transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
    var motionState = new Ammo.btDefaultMotionState( transform );

    var localInertia = new Ammo.btVector3( 0, 0, 0 );
    physicsShape.calculateLocalInertia( mass, localInertia );

    var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
    var body = new Ammo.btRigidBody( rbInfo );

    threeObject.userData.physicsBody = body;

    scene.add( threeObject );

    if ( mass > 0 ) {
      rigidBodies.push( threeObject );

      // Disable deactivation
      body.setActivationState( 4 );
    }

    physicsWorld.addRigidBody( body );
    return body;

  }

  function createRandomColor() {
    return Math.floor( Math.random() * ( 1 << 24 ) );
  }

  function createMaterial() {
    return new THREE.MeshPhongMaterial( { color: createRandomColor() } );
  }

  function accelerate() {
    gEngineForce = maxEngineForce;
    gBreakingForce = 0;
  }
  function decelerate() {
    gBreakingForce = maxBreakingForce;
    gEngineForce = 0;
  }
  function steerLeft() {
    gVehicleSteering += steeringIncrement;
    if (	gVehicleSteering > steeringClamp)
    gVehicleSteering = steeringClamp;

  }
  function steerRight() {
    gVehicleSteering -= steeringIncrement;
    if (	gVehicleSteering < -steeringClamp)
    gVehicleSteering = -steeringClamp;
  }

  function initInput() {

    window.addEventListener( 'keydown', function( event ) {
      switch ( event.keyCode ) {
        // W and
        case 87:
        // Up Arrow
        case 38:
        accelerate();
        break;
        // S and
        case 83:
        // Down Arrow
        case 40:
        decelerate();
        break;
        // A and
        case 65:
        // Left Arrow
        case 37:
        steerLeft();
        break;
        // D and
        case 68:
        // Right Arrow
        case 39:
        steerRight();
        break;
      }
    }, false );

    // window.addEventListener( 'keyup', function( event ) {
    //   accelerate = false;
    // }, false );

    window.addEventListener( 'mousedown', function( event ) {
      if ( ! clickRequest ) {
        mouseCoords.set(
          ( event.clientX / window.innerWidth ) * 2 - 1,
          - ( event.clientY / window.innerHeight ) * 2 + 1
        );
        clickRequest = true;
      }
    }, false );
  }

  function processClick() {
    if ( clickRequest ) {
      raycaster.setFromCamera( mouseCoords, camera );
      // Creates a ball
      var ballMass = 3;
      var ballRadius = 0.4;
      var ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 18, 16 ), ballMaterial );
      ball.castShadow = true;
      ball.receiveShadow = true;
      var ballShape = new Ammo.btSphereShape( ballRadius );
      ballShape.setMargin( margin );
      pos.copy( raycaster.ray.direction );
      pos.add( raycaster.ray.origin );
      quat.set( 0, 0, 0, 1 );
      var ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );
      ballBody.setFriction( 0.5 );
      pos.copy( raycaster.ray.direction );
      pos.multiplyScalar( 14 );
      ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
      clickRequest = false;
    }
  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function animate() {

    requestAnimationFrame( animate );

    render();
    stats.update();

  }

  function render() {

    var deltaTime = clock.getDelta();

    updateCar();

    updatePhysics( deltaTime );

		processClick();

    controls.update( deltaTime );

    renderer.render( scene, camera );

    time += deltaTime;

  }

  function updatePhysics( deltaTime ) {
    physicsWorld.stepSimulation( deltaTime, 10 );
    // Update rigid bodies
    for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
      var objThree = rigidBodies[ i ];
      var objPhys = objThree.userData.physicsBody;
      var ms = objPhys.getMotionState();
      if ( ms ) {
        ms.getWorldTransform( transformAux1 );
        var p = transformAux1.getOrigin();
        var q = transformAux1.getRotation();
        objThree.position.set( p.x(), p.y(), p.z() );
        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
      }
    }
  }

  </script>

</body>
</html>
